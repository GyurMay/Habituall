{"ast":null,"code":"'use strict';\n\nvar _createForOfIteratorHelper = require(\"/Users/gyurmeydorj/Habituall/client/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\nvar _objectSpread = require(\"/Users/gyurmeydorj/Habituall/client/node_modules/@babel/runtime/helpers/objectSpread2.js\").default;\nvar copyProperty = function copyProperty(to, from, property, ignoreNonConfigurable) {\n  // `Function#length` should reflect the parameters of `to` not `from` since we keep its body.\n  // `Function#prototype` is non-writable and non-configurable so can never be modified.\n  if (property === 'length' || property === 'prototype') {\n    return;\n  }\n\n  // `Function#arguments` and `Function#caller` should not be copied. They were reported to be present in `Reflect.ownKeys` for some devices in React Native (#41), so we explicitly ignore them here.\n  if (property === 'arguments' || property === 'caller') {\n    return;\n  }\n  var toDescriptor = Object.getOwnPropertyDescriptor(to, property);\n  var fromDescriptor = Object.getOwnPropertyDescriptor(from, property);\n  if (!canCopyProperty(toDescriptor, fromDescriptor) && ignoreNonConfigurable) {\n    return;\n  }\n  Object.defineProperty(to, property, fromDescriptor);\n};\n\n// `Object.defineProperty()` throws if the property exists, is not configurable and either:\n//  - one its descriptors is changed\n//  - it is non-writable and its value is changed\nvar canCopyProperty = function canCopyProperty(toDescriptor, fromDescriptor) {\n  return toDescriptor === undefined || toDescriptor.configurable || toDescriptor.writable === fromDescriptor.writable && toDescriptor.enumerable === fromDescriptor.enumerable && toDescriptor.configurable === fromDescriptor.configurable && (toDescriptor.writable || toDescriptor.value === fromDescriptor.value);\n};\nvar changePrototype = function changePrototype(to, from) {\n  var fromPrototype = Object.getPrototypeOf(from);\n  if (fromPrototype === Object.getPrototypeOf(to)) {\n    return;\n  }\n  Object.setPrototypeOf(to, fromPrototype);\n};\nvar wrappedToString = function wrappedToString(withName, fromBody) {\n  return \"/* Wrapped \".concat(withName, \"*/\\n\").concat(fromBody);\n};\nvar toStringDescriptor = Object.getOwnPropertyDescriptor(Function.prototype, 'toString');\nvar toStringName = Object.getOwnPropertyDescriptor(Function.prototype.toString, 'name');\n\n// We call `from.toString()` early (not lazily) to ensure `from` can be garbage collected.\n// We use `bind()` instead of a closure for the same reason.\n// Calling `from.toString()` early also allows caching it in case `to.toString()` is called several times.\nvar changeToString = function changeToString(to, from, name) {\n  var withName = name === '' ? '' : \"with \".concat(name.trim(), \"() \");\n  var newToString = wrappedToString.bind(null, withName, from.toString());\n  // Ensure `to.toString.toString` is non-enumerable and has the same `same`\n  Object.defineProperty(newToString, 'name', toStringName);\n  Object.defineProperty(to, 'toString', _objectSpread(_objectSpread({}, toStringDescriptor), {}, {\n    value: newToString\n  }));\n};\nvar mimicFn = function mimicFn(to, from) {\n  var _ref = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},\n    _ref$ignoreNonConfigu = _ref.ignoreNonConfigurable,\n    ignoreNonConfigurable = _ref$ignoreNonConfigu === void 0 ? false : _ref$ignoreNonConfigu;\n  var name = to.name;\n  var _iterator = _createForOfIteratorHelper(Reflect.ownKeys(from)),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var property = _step.value;\n      copyProperty(to, from, property, ignoreNonConfigurable);\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n  changePrototype(to, from);\n  changeToString(to, from, name);\n  return to;\n};\nmodule.exports = mimicFn;","map":{"version":3,"names":["_createForOfIteratorHelper","require","default","_objectSpread","copyProperty","to","from","property","ignoreNonConfigurable","toDescriptor","Object","getOwnPropertyDescriptor","fromDescriptor","canCopyProperty","defineProperty","undefined","configurable","writable","enumerable","value","changePrototype","fromPrototype","getPrototypeOf","setPrototypeOf","wrappedToString","withName","fromBody","concat","toStringDescriptor","Function","prototype","toStringName","toString","changeToString","name","trim","newToString","bind","mimicFn","_ref","arguments","length","_ref$ignoreNonConfigu","_iterator","Reflect","ownKeys","_step","s","n","done","err","e","f","module","exports"],"sources":["/Users/gyurmeydorj/Habituall/client/node_modules/mem/node_modules/mimic-fn/index.js"],"sourcesContent":["'use strict';\n\nconst copyProperty = (to, from, property, ignoreNonConfigurable) => {\n\t// `Function#length` should reflect the parameters of `to` not `from` since we keep its body.\n\t// `Function#prototype` is non-writable and non-configurable so can never be modified.\n\tif (property === 'length' || property === 'prototype') {\n\t\treturn;\n\t}\n\n\t// `Function#arguments` and `Function#caller` should not be copied. They were reported to be present in `Reflect.ownKeys` for some devices in React Native (#41), so we explicitly ignore them here.\n\tif (property === 'arguments' || property === 'caller') {\n\t\treturn;\n\t}\n\n\tconst toDescriptor = Object.getOwnPropertyDescriptor(to, property);\n\tconst fromDescriptor = Object.getOwnPropertyDescriptor(from, property);\n\n\tif (!canCopyProperty(toDescriptor, fromDescriptor) && ignoreNonConfigurable) {\n\t\treturn;\n\t}\n\n\tObject.defineProperty(to, property, fromDescriptor);\n};\n\n// `Object.defineProperty()` throws if the property exists, is not configurable and either:\n//  - one its descriptors is changed\n//  - it is non-writable and its value is changed\nconst canCopyProperty = function (toDescriptor, fromDescriptor) {\n\treturn toDescriptor === undefined || toDescriptor.configurable || (\n\t\ttoDescriptor.writable === fromDescriptor.writable &&\n\t\ttoDescriptor.enumerable === fromDescriptor.enumerable &&\n\t\ttoDescriptor.configurable === fromDescriptor.configurable &&\n\t\t(toDescriptor.writable || toDescriptor.value === fromDescriptor.value)\n\t);\n};\n\nconst changePrototype = (to, from) => {\n\tconst fromPrototype = Object.getPrototypeOf(from);\n\tif (fromPrototype === Object.getPrototypeOf(to)) {\n\t\treturn;\n\t}\n\n\tObject.setPrototypeOf(to, fromPrototype);\n};\n\nconst wrappedToString = (withName, fromBody) => `/* Wrapped ${withName}*/\\n${fromBody}`;\n\nconst toStringDescriptor = Object.getOwnPropertyDescriptor(Function.prototype, 'toString');\nconst toStringName = Object.getOwnPropertyDescriptor(Function.prototype.toString, 'name');\n\n// We call `from.toString()` early (not lazily) to ensure `from` can be garbage collected.\n// We use `bind()` instead of a closure for the same reason.\n// Calling `from.toString()` early also allows caching it in case `to.toString()` is called several times.\nconst changeToString = (to, from, name) => {\n\tconst withName = name === '' ? '' : `with ${name.trim()}() `;\n\tconst newToString = wrappedToString.bind(null, withName, from.toString());\n\t// Ensure `to.toString.toString` is non-enumerable and has the same `same`\n\tObject.defineProperty(newToString, 'name', toStringName);\n\tObject.defineProperty(to, 'toString', {...toStringDescriptor, value: newToString});\n};\n\nconst mimicFn = (to, from, {ignoreNonConfigurable = false} = {}) => {\n\tconst {name} = to;\n\n\tfor (const property of Reflect.ownKeys(from)) {\n\t\tcopyProperty(to, from, property, ignoreNonConfigurable);\n\t}\n\n\tchangePrototype(to, from);\n\tchangeToString(to, from, name);\n\n\treturn to;\n};\n\nmodule.exports = mimicFn;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}